generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                Int            @id @default(autoincrement())
  email             String         @unique
  password          String
  displayName       String
  avatarUrl         String?
  status            UserStatus     @default(ACTIVE)
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  auditLogs         AuditLog[]
  proxyActions      AuditLog[]     @relation("ProxyActions")
  events            Event[]
  mediaAssets       MediaAsset[]
  notifications     Notification[]
  sentNotifications Notification[] @relation("NotificationSender")
  player            Player?
  requests          Request[]
  requestOperations RequestEvent[] @relation("RequestOperator")
  singer            Singer?
  userRoles         UserRole[]
  wishSongs         WishSong[]
}

model Role {
  id          Int        @id @default(autoincrement())
  name        String     @unique
  displayName String
  description String?
  permissions String
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  userRoles   UserRole[]
}

model UserRole {
  id        Int      @id @default(autoincrement())
  userId    Int
  roleId    Int
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      Role     @relation(fields: [roleId], references: [id])

  @@unique([userId, roleId])
}

model Singer {
  id           Int           @id @default(autoincrement())
  userId       Int           @unique
  stageName    String
  bio          String?
  isActive     Boolean       @default(true)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  eventSingers EventSinger[]
  requests     Request[]
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  singerSongs  SingerSong[]
  singerTags   SingerTag[]
  wishSongs    WishSong[]
}

model Tag {
  id          Int         @id @default(autoincrement())
  name        String      @unique
  type        TagType
  description String?
  createdAt   DateTime    @default(now())
  singerTags  SingerTag[]
  songs       Song[]      @relation("SongGenre")
}

model SingerTag {
  id        Int      @id @default(autoincrement())
  singerId  Int
  tagId     Int
  createdAt DateTime @default(now())
  singer    Singer   @relation(fields: [singerId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id])

  @@unique([singerId, tagId])
}

model Song {
  id             Int           @id @default(autoincrement())
  title          String
  language       String?
  genreTagId     Int?
  era            String?
  originalArtist String?
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  requests       Request[]
  singerSongs    SingerSong[]
  genreTag       Tag?          @relation("SongGenre", fields: [genreTagId], references: [id])
  songVersions   SongVersion[]
}

model SongVersion {
  id             Int       @id @default(autoincrement())
  songId         Int
  versionLabel   String
  originalArtist String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  requests       Request[]
  song           Song      @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@unique([songId, versionLabel])
}

model SingerSong {
  id             Int      @id @default(autoincrement())
  singerId       Int
  songId         Int
  learned        Boolean  @default(false)
  timesRequested Int      @default(0)
  notes          String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  singer         Singer   @relation(fields: [singerId], references: [id], onDelete: Cascade)
  song           Song     @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@unique([singerId, songId])
}

model Player {
  id        Int        @id @default(autoincrement())
  userId    Int?       @unique
  name      String
  nickname  String?
  level     String?    @default("新手")
  birthday  DateTime?
  joinedAt  DateTime   @default(now())
  notes     String?
  photoKey  String?
  isActive  Boolean    @default(true)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  user      User?      @relation(fields: [userId], references: [id])
  requests  Request[]
  wishSongs WishSong[]
}

model Event {
  id           Int           @id @default(autoincrement())
  title        String
  venue        String?
  startsAt     DateTime
  endsAt       DateTime
  hostUserId   Int
  status       EventStatus   @default(PLANNED)
  description  String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  host         User          @relation(fields: [hostUserId], references: [id])
  eventSingers EventSinger[]
  requests     Request[]
}

model EventSinger {
  id        Int      @id @default(autoincrement())
  eventId   Int
  singerId  Int
  createdAt DateTime @default(now())
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  singer    Singer   @relation(fields: [singerId], references: [id], onDelete: Cascade)

  @@unique([eventId, singerId])
}

model Request {
  id            Int            @id @default(autoincrement())
  eventId       Int
  playerId      Int?
  userId        Int?
  singerId      Int?
  songId        Int
  songVersionId Int?
  requestedAt   DateTime       @default(now())
  desiredTime   String?
  status        RequestStatus  @default(QUEUED)
  notes         String?
  priorityIndex Int?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  event         Event          @relation(fields: [eventId], references: [id])
  player        Player?        @relation(fields: [playerId], references: [id])
  user          User?          @relation(fields: [userId], references: [id])
  singer        Singer?        @relation(fields: [singerId], references: [id])
  song          Song           @relation(fields: [songId], references: [id])
  songVersion   SongVersion?   @relation(fields: [songVersionId], references: [id])
  requestEvents RequestEvent[]
}

model RequestEvent {
  id             Int      @id @default(autoincrement())
  requestId      Int
  type           String
  occurredAt     DateTime @default(now())
  operatorUserId Int?
  reason         String?
  payload        String?
  request        Request  @relation(fields: [requestId], references: [id], onDelete: Cascade)
  operator       User?    @relation("RequestOperator", fields: [operatorUserId], references: [id])
}

model WishSong {
  id             Int            @id @default(autoincrement())
  playerId       Int?
  userId         Int?
  singerId       Int?
  title          String
  originalArtist String?
  status         WishSongStatus @default(PENDING)
  notes          String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  player         Player?        @relation(fields: [playerId], references: [id])
  user           User?          @relation(fields: [userId], references: [id])
  singer         Singer?        @relation(fields: [singerId], references: [id])
}

model MediaAsset {
  id        Int      @id @default(autoincrement())
  ownerType String
  ownerId   Int
  key       String   @unique
  mimeType  String
  meta      String?
  createdBy Int
  createdAt DateTime @default(now())
  creator   User     @relation(fields: [createdBy], references: [id])
}

model Notification {
  id        Int              @id @default(autoincrement())
  userId    Int
  senderId  Int?
  type      NotificationType
  title     String
  content   String
  payload   String?
  readAt    DateTime?
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  sender    User?            @relation("NotificationSender", fields: [senderId], references: [id])
}

model Analytics {
  id        Int      @id @default(autoincrement())
  date      DateTime
  metric    String
  entityId  Int?
  value     Float
  createdAt DateTime @default(now())

  @@unique([date, metric, entityId])
}

model AuditLog {
  id          Int      @id @default(autoincrement())
  actorUserId Int
  proxyUserId Int?
  entity      String
  entityId    Int?
  action      String
  before      String?
  after       String?
  reason      String?
  createdAt   DateTime @default(now())
  actor       User     @relation(fields: [actorUserId], references: [id])
  proxy       User?    @relation("ProxyActions", fields: [proxyUserId], references: [id])
}

enum UserStatus {
  ACTIVE
  DISABLED
  SUSPENDED
}

enum TagType {
  GENRE
  STYLE
  LANGUAGE
  ERA
}

enum EventStatus {
  PLANNED
  ACTIVE
  COMPLETED
  CANCELLED
}

enum RequestStatus {
  QUEUED
  ASSIGNED
  ACCEPTED
  DECLINED
  PERFORMING
  COMPLETED
  CANCELLED
}

enum WishSongStatus {
  PENDING
  APPROVED
  REJECTED
  ADDED
}

enum NotificationType {
  SYSTEM
  REQUEST
  WISH_SONG
  EVENT
  PERSONAL
}
